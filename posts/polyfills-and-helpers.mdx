---
title: Polyfills and helpers - How to save your bundle size
published: false
listed: true
date: '05/27/2022'
lastUpdateDate: '05/27/2022'
tags: javascript
language: English
---

As web programmers, we'd like to use most recent features. On the other hand, how to make our modern code work on older browsers that don't understand those feature?

There are two tools for that:

+ Polyfills
+ Transpilers

## Polyfills vs transpilers

### Polyfills

A polyfill is code that updates/adds new funtions or properties.

For example, `string.prototype.matchAll` was [first introduced in ES2020](https://www.freecodecamp.org/news/javascript-new-features-es2020/) and can not work on Chrome under 67 according to [can-i-use](https://caniuse.com/?search=string.matchAll). If your users are using Chrome under 67, there's no `string.prototyp.matchAll`, so such code will fail.

For this case, "polyfill" will "fills in" the gap and adds missing implmentation by modifying the prototype chain of `String`, without replacing the source code.

Write code like this:

```javascript
const matchString = 'abbbbc'.matchAll(/a/, 'd');
```

Then run it through a transpiler such as [Babel](https://babeljs.io/docs/en/):

```javascript
require("core-js/modules/es.string.match-all.js");

var matchString = 'abbbbc'.matchAll(/a/, 'd');
```

### Transpilers

A transpiler is a tool that translates your source code to another code. It parse modern syntaxs and rewrite it using older syntaxs to make them work in older browsers.

[spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)ï¼Œ[async/await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function), [Class](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes) are some good examples of this case.

Do same thing with this code:

```javascript
const extendsObj = { ...{ a: 'a' } };
```

You will get:

```javascript
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var extendsObj = _objectSpread({}, {
  a: 'a'
});
```

Notice that there are some functions imported from `@babel/runtime/helpers`, which help to transpil code. They're what I refer to as "**Helpers**".


